#!/usr/bin/env python
import argparse
import datetime
import os
import pprint
import email
from email_message import get_connection
from pygments import highlight
from pygments.formatters import TerminalFormatter
import pygments.lexers
from pygments.token import Keyword, Name, Punctuation, Comment, String, Whitespace
import simplejson
import sys

from mailmachine import enqueue, send
from mailmachine.configuration import load_config
from mailmachine.queue import MailQueue, HotQueue


def _print(result, colors):
    json = simplejson.dumps(result, sort_keys=True, indent=4)
    if colors:
        print highlight(json, pygments.lexers.get_lexer_by_name('json'), TerminalFormatter())
    else:
        pprint.pprint(json)

def _build_attachments(attachments_info):
    attachments = []
    for file_path, mime in attachments_info:
        attachments.append((os.path.basename(file_path),
                            open(file_path, 'r').read(),
                            mime))
    return attachments

def _get_mail_params(args):
    return {
        'subject': args.subject,
        'body': args.body,
        'recipients': args.recipients,
        'from_email': args.from_email,
        'recipients': args.recipients,
        'attachments': args.attachments,
    }

def do_enqueue(args, config):
    c = config['redis']
    mail_queue = MailQueue(c['mail_queue'], host=c['host'], port=c['port'],
                           password=c.get('password'))

    mail = _get_mail_params(args)
    mail['attachments'] = _build_attachments(mail.get('attachments', []))
    enqueue(mail_queue, **mail)

def do_send(args, config):
    mc = config['mailing']
    mail = _get_mail_params(args)
    connection = get_connection(mc['host'], mc['port'], username=mc['username'],
                                password=mc['password'], use_tls=mc['use_tls'])
    mail['attachments'] = _build_attachments(mail.get('attachments', []))
    send(connection, **mail)


separator = (Comment, '\n\n-------------------------------------------------------------------\n\n')

def _format_message(message):
    tokens = []
    parser = email.Parser.Parser()
    sender, recipients, msg = message
    sender = email.utils.parseaddr(sender)
    tokens.append((Keyword.Type, 'Sender: '))
    tokens.append((Name.Variable, email.utils.formataddr([p[0] for s in sender for p in email.header.decode_header(s)])))
    tokens.append((Whitespace, '\n'))
    tokens.append((Keyword.Type, 'Recipients: '))
    for r in recipients:
        for i,p in enumerate(email.header.decode_header(r)):
            if i > 0:
                tokens.append((Punctuation, ', '))
            tokens.append((Name.Variable, p[0]))
    tokens.append((Whitespace, '\n'))
    msg = parser.parsestr(msg.encode('utf-8'))
    tokens.append((Keyword.Type, 'Subject: '))
    tokens.append((Name.Variable, msg.get('Subject')))
    tokens.append((Whitespace, '\n'))
    body = None
    attachments = []
    for part in msg.walk():
        if part.get('Content-Disposition', None):
            ds = {}
            for p in part.get('Content-Disposition').split(';'):
                if '=' in p:
                    n, v = p.split('=', 1)
                    ds[n.strip().lower()] = v.strip()
            filename = next((v for n,v in ds.items() if n.lower()=='filename'), None)
            if filename:
                attachments.append((filename, part.get_content_type()))
        elif part.get_content_type() == 'text/plain':
            body = '' if body is None else body
            body += unicode(
                part.get_payload(decode=True),
                part.get_content_charset(),
                'replace'
            ).encode('utf8','replace')
    tokens.append((Keyword.Type, 'Body: '))
    tokens.append((Whitespace, '\n'))
    tokens.append((Whitespace, '\n'))
    tokens.append((String, body.decode('utf-8')))
    tokens.append((Whitespace, '\n'))
    tokens.append((Whitespace, '\n'))
    if attachments:
        tokens.append((Keyword.Type, 'Attachments: '))
        for i,a in enumerate(attachments):
            if i > 0:
                tokens.append((Punctuation, ', '))
            tokens.append((Name.Variable, a[0]))
            tokens.append((Whitespace, ' '))
            tokens.append((Name.Tag, a[1]))
    return tokens

def do_failures_snapshot(args, config):
    c = config['redis']
    mail_errors_queue = HotQueue(c['mail_errors_queue'], host=c['host'], port=c['port'],
                                 password=c.get('password'))
    tokens = []
    for mail_error in mail_errors_queue.snapshot():
        tokens.append(separator)
        tokens.append((Keyword.Type, 'UID: '))
        tokens.append((Name.Variable, mail_error['uid']))
        tokens.append((Whitespace, '\n'))
        tokens.append((Keyword.Type, 'Exception: '))
        tokens.append((Name.Variable, mail_error['excepion']))
        tokens.append((Whitespace, '\n'))
        tokens.append((Keyword.Type, 'Sent: '))
        tokens.append((Name.Variable, datetime.datetime
                                              .fromtimestamp(mail_error['timestamp'])
                                              .strftime('%Y-%m-%d %H:%m')))
        tokens.append(separator)
        tokens.extend(_format_message(mail_error['msg']))
        tokens.append(separator)
        tokens.append((Whitespace, '\n'))
    formatter = TerminalFormatter()
    formatter.format(tokens, sys.stdout)


def do_snapshot(args, config):
    c = config['redis']
    mail_queue = MailQueue(c['mail_queue'], host=c['host'], port=c['port'],
                           password=c.get('password'))
    tokens = []
    for message in mail_queue.snapshot():
        tokens.append(separator)
        tokens.extend(_format_message(message))
        tokens.append(separator)
    formatter = TerminalFormatter()
    formatter.format(tokens, sys.stdout)

def do_cleanup(args, config):
    c = config['redis']
    mail_queue = MailQueue(c['mail_queue'], host=c['host'], port=c['port'],
                           password=c.get('password'))
    for m in mail_queue._queue.consume(block=False):
        print 'Dropping:', m[0]


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Put mail to mailing queue')
    default_config = '/etc/mailmachine.yaml'
    parser.add_argument('-c', '--config', help='Specify configuration file',
                        default=default_config if os.path.exists(default_config) else None)
    subparsers = parser.add_subparsers(help='Subcommands help')

    enqueue_parser = subparsers.add_parser('enqueue')
    enqueue_parser.set_defaults(func=do_enqueue)

    send_parser = subparsers.add_parser('send')
    send_parser.set_defaults(func=do_send)

    for p in [send_parser, enqueue_parser]:
        p.add_argument('-s', '--subject', action='store', required=True)
        p.add_argument('-b', '--body', action='store', required=True)
        p.add_argument('-f', '--from-email', action='store', required=True)
        p.add_argument('-r', '--recipient', action='append', dest='recipients',
                       required=True, metavar='RECIPIENT', help='you can use this option multiple times')
        p.add_argument('-a', '--attachment', action='append', metavar=('PATH', 'MIME_TYPE'),
                       dest='attachments', nargs=2, default=[],
                       help=('for example: ~/file.pdf application/pdf'))

    snapshot_parser = subparsers.add_parser('snapshot')
    failure_snapshot_parser = subparsers.add_parser('failures-snapshot')
    for p in [snapshot_parser, failure_snapshot_parser]:
        p.add_argument('--no-colors', help='Print result in colors',
                       default=False, action='store_true')
    snapshot_parser.set_defaults(func=do_snapshot)
    failure_snapshot_parser.set_defaults(func=do_failures_snapshot)

    cleanup_parser = subparsers.add_parser('cleanup')
    cleanup_parser.set_defaults(func=do_cleanup)

    for p in [cleanup_parser, snapshot_parser, enqueue_parser, send_parser, failure_snapshot_parser]:
        p.add_argument('-c', '--config', help='Specify configuration file',
                        default=default_config if os.path.exists(default_config) else None)

    args = parser.parse_args()
    config = load_config(args.config)
    args.func(args, config)
